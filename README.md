## Clocks and crocodiles

Здесь лежит jupyter-notebook для решения задач 1.1 и 1.2 на стажировку в Samsung

## Использованные внешние модули

Для работы приложенного ноутбука потребуются Keras (Backend TensorFlow), numpy, scipy и matplotlib

## Описание решения
### Задача 1.1
#### Подход
Для классификации изображений я использовал простую сверточную сеть - два сверточных слоя по 32 ядра 3х3, MaxPooling 2х2, два сверточных по 64 ядра 3х3, MaxPooling 2х2, Flatten-слой для вытягивания карты свойств в вектор, полносвязный слой из 128 нейронов и наконец выход из двух нейронов. Выборка была разделена на случайные части из 900 и 100 изображений для тренировки и тестирования соответственно (везде поровну изображений обоих классов). Результат на тестовой выборке составил 92%.

Кроме того, я также обучил сиамскую сеть, состоящую из двух сверточных сетей, объединенных слоем, считающим расстояние между выходами полносвязных слоев. Модель обучается на парах изображений. Каждая пара имеют метку в зависимости от того, лежат ли изображения в одном классе. Таким образом, мы пытаемся максимизировать расстояние для изображений из разных классов и минимизировать его для изображений из одного класса. После обучения на 36000 пар разных сочетаний крокодилов и часов, я получил точность 99.57% для определения принадлежности изображений одному классу. К сожалению, моя модель не решает исходную задачу и не дает ответ на вопрос к какому классу принадлежат изображения. 

#### Что можно улучшить
В первую очередь стоит увеличить количество ядер свертки. Возможно, их было недостаточно, т.к. изображения из выборки легко разбиваются на подклассы, например, механические часы и электронные часы. Также, стоит поэкспериментировать с выбором оптимизатора, темпа обучения и других параметров сети.

### Задача 1.2
#### Подход
Поскольку сверточная нейронная сеть имеет на более глубоких слоях более "общие" признаки, описывающие изображение в целом, я решил, что следует искать такие изображения, чтобы их карты свойств на послднем сверточном слое отличались минимально. 

Порядок действий:
1. Обучение CNN-классификатора
2. Копирование всех слоев кроме полносвязных и их весов в новую сеть
3. Прямое прохождение всех изображений через новую сеть
4. Усреднение вытянутых карт свойств всех изображений отдельно для каждого класса
5. Поиск изображений, чьи карты свойств равноудалены по евклидовой норме от "средних" крокодилов и часов
6. Изображение с малой нормой можно считать похожим одновременно и на крокодила, и на часы

Результат, однако, получился двоякий: выданных крокодилов действительно легко спутать с часами, однако часы меньше похожи на крокодилов - в основном только цветом. Скорее всего, пасть крокодила зачастую имеет общие черты со стрелками на циферблате, однако трудно представить часы, схожие по форме или хотя бы по цвету с крокодилом.

#### Что можно улучшить
Опять же, стоит поэкспериментировать с архитектурой сверточной сети, возможно большее количество ядер даст лучший результат. Также, имеет смысл обращать внимание не только на выход последнего сверточного слоя, но и на другие слои, т.к. возможно, последний слой имеет слишком высокоуровневую информацию, которую стоит разбавить более локальными признаками. Сиамскую сеть также наверняка можно приспособить для поиска нужных изображений, т.к. сиамские сети как правило используются для подобных задач (например, FindFace). Так, можно было бы каждое изображение в паре со всеми остальными прогнать через обученную сиамскую сеть и опять же найти изображение, в среднем равноудаленное от обоих классов. 
